Permutations 
## Problem Statement
Given an array of distinct integers nums, return all possible permutations.  
Each permutation must contain exactly all elements from nums, and the order matters.

### Example
*Input*:

nums = [1, 2, 3]

*Output*:

[ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2] ]

---

## Approach

We solve this problem using *backtracking*:
1. Use a recursive function backtrack(start) which tries to fix one element at each position.
2. For every index start, we swap it with each index i from start to end:
   - Swap → put element at correct position.
   - Recurse → solve for remaining elements.
   - Swap back → restore original order for the next iteration.
3. When start == len(nums), we have a complete permutation, so add it to the result.

---


Dry Run

Input: nums = [1,2,3]

Step 1:

start=0
Swap nums[0] with nums[0] → [1,2,3]
Recurse…


Step 2:

start=1
Swap nums[1] with nums[1] → [1,2,3]
Recurse…


Step 3:

start=2
Swap nums[2] with nums[2] → [1,2,3]
Reached base case → store [1,2,3].


Backtrack, swap back.


---

Continue this process:

Swap indices (1,2) → [1,3,2] → add [1,3,2].

Backtrack, return to start=0.


Swap (0,1) → [2,1,3] → recurse, generate [2,1,3] and [2,3,1].
Swap (0,2) → [3,2,1] → recurse, generate [3,2,1] and [3,1,2].


---

Final Result

[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,2,1],
  [3,1,2]
]


---

Complexity Analysis

Time Complexity: O(n * n!)

There are n! permutations.

Copying each permutation takes O(n).


Space Complexity: O(n) (recursion depth).
