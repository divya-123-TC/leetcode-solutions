 BST Iterator

### ğŸ“˜ Problem Statement
Design an *iterator* for a *Binary Search Tree (BST)*.  
The iterator should return the *next smallest number* in the BST (in ascending order).

Implement the following methods:

- __init__(root) â†’ Initialize the iterator with the root node.  
- next() â†’ Return the next smallest element in the BST.  
- hasNext() â†’ Return whether there are more elements in the BST.

---

### ğŸ§  Intuition
A BSTâ€™s *inorder traversal* (Left â†’ Root â†’ Right) gives nodes in *sorted order*.  
We use a *stack* to simulate this traversal *iteratively* instead of using recursion.



ğŸªœ How It Works (Step-by-Step)

ğŸ”¹ Initialization

Start from the root node.

Keep pushing all left nodes into the stack.

The top of the stack will always be the next smallest element.


ğŸ”¹ next() Method

1. Pop the top element (res) â€” thatâ€™s the smallest unvisited node.


2. If it has a right child, push all its left descendants into the stack.


3. Return res.val.



ğŸ”¹ hasNext() Method

Returns True if the stack is not empty, else False.



---

ğŸŒ¿ Example

Input BST:

7
      / \
     3   15
        /  \
       9   20

Steps:

Operation	Output	Stack (Top â†’ Bottom)

Init	-	[7, 3]
next()	3	[7, 15, 9]
next()	7	[15, 9]
next()	9	[15]
next()	15	[20]
next()	20	[]
hasNext()	False	[]


Inorder Sequence: [3, 7, 9, 15, 20]


---

â± Time & Space Complexity

Type	Complexity	Explanation

âŒ› Time	O(1) average per operation	Each node is pushed and popped once
ğŸ’¾ Space	O(h)	Stack stores at most height h nodes


 Summary

Traverses BST in sorted order using stack.

More efficient than recursive inorder traversal.

Commonly asked interview question.
