Rotting Oranges

We are given a grid representing oranges in a box:
- 0 → empty cell
- 1 → fresh orange
- 2 → rotten orange

Every minute, any fresh orange adjacent (up, down, left, right) to a rotten orange becomes rotten. We need to return the *minimum number of minutes* that must elapse until no fresh orange remains. If impossible, return -1.

---

## Approach

We will use *Breadth-First Search (BFS)* to simulate the rotting process:

1. Traverse the grid to count fresh oranges and add positions of all rotten oranges to a queue.
2. For each rotten orange in the queue, try to rot all adjacent fresh oranges.
3. Increase time after processing one level (minute).
4. If any fresh orange remains after BFS, return -1. Otherwise, return time.

---



Example

grid = [
  [2,1,1],
  [1,1,0],
  [0,1,1]
]
sol = Solution()
print(sol.orangesRotting(grid))  # Output: 4

Explanation: It takes 4 minutes to rot all fresh oranges.



---

Key Notes

BFS ensures all oranges at the same minute are processed together.

Using deque helps efficient popping from the front.

Always check bounds and fresh condition in BFS.
