Subsets II 
Problem Statement

Given an integer array nums that may contain duplicates, return all possible subsets (the power set).

The solution set must not contain duplicate subsets.

Return the solution in any order.


Example:

Input: nums = [1,2,2]
Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]


---

Approach

We use Backtracking (DFS):

1. At each index, we decide → take this number or skip it.


2. If we take it → add to current subset, recurse, then backtrack.


3. If we skip → move to next index, but skip all duplicates of the current number (to avoid duplicate subsets).


4. Base case → when i == len(nums), save the current subset.



Key Idea:

Sort the input first (so duplicates are adjacent).

When skipping, jump over duplicates using a while loop.



                

Dry Run

Input: nums = [1,2,2] (sorted already)

Start i=0 → nums[0] = 1

Take 1 → subset = [1]

i=1 → nums[1] = 2

Take 2 → subset = [1,2]

i=2 → nums[2] = 2

Take 2 → [1,2,2] → save

Skip 2 → [1,2] → save



Skip duplicate 2 → backtrack → [1] → save



Skip 1 → subset = []

i=1 → nums[1] = 2

Take 2 → [2]

i=2 → Take 2 → [2,2] → save

Skip 2 → [2] → save


Skip duplicate 2 → [] → save





Final Result: [[], [1], [1,2], [1,2,2], [2], [2,2]]


---

Complexity

Time Complexity: O(2^n) (every element is either chosen or not chosen, though skipping duplicates prunes some calls).

Space Complexity: O(n) recursion stack + result storage.
