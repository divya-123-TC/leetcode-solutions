Burst Balloons 

ğŸ“Œ Problem Description

You are given n balloons, each balloon has a number written on it.
When you burst balloon i, you gain:

nums[left] * nums[i] * nums[right]

where left and right are the nearest balloons still remaining.

After bursting balloon i, it disappears.
The goal is to find the maximum coins you can collect by bursting balloons in the best order.


---

ğŸ“ Example

Input:

nums = [3,1,5,8]

Output:

167

One optimal order: Burst 1 â†’ Burst 5 â†’ Burst 3 â†’ Burst 8
Total coins = 167


---

ğŸ§  Key Insight

Instead of choosing which balloon to burst first,
we choose which balloon to burst last in each range.

This allows us to split the problem:

dfs(l, r) = max coins from bursting balloons in range [l, r]

Try each i in [l, r] as the last balloon:

coins = nums[l-1] * nums[i] * nums[r+1]
coins += dfs(l, i-1)  # left side
coins += dfs(i+1, r)  # right side

Choose the best (max) among all choices.


---

ğŸ§© Why Padding?

We add 1 at the start and end:

nums = [1] + nums + [1]

This ensures boundaries always exist â†’ no extra checks.


---

â³ Complexity Analysis

Approach	Time	Space

DFS + DP (Memoization)	O(nÂ³)	O(nÂ²)



 Summary

Hard problem due to adjacency change after bursting.

Think last balloon instead of first.

Divide into left and right subproblems.

Use Dynamic Programming + Memoization to avoid repetition.
