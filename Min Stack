Min Stack 

##  Problem Statement
Design a stack that supports the following operations in *O(1)* time:
- push(val) → Push element val onto the stack.  
- pop() → Remove the element on top of the stack.  
- top() → Get the top element.  
- getMin() → Retrieve the minimum element in the stack.



## Approach
We use a *stack of pairs* instead of a plain stack.  

Each element in the stack stores:
- [val, current_min]  
  where current_min = minimum value in the stack *up to that element*.  

So:
- When pushing, we compute the new minimum as min(val, previous_min).  
- When popping, we remove the last pair.  
- top() returns the last value.  
- getMin() returns the last minimum stored.

This ensures *O(1)* for all operations.





⏱ Complexity Analysis

Time Complexity:

push() → O(1)

pop() → O(1)

top() → O(1)

getMin() → O(1)


Space Complexity: O(n) for storing elements and their minimums.





Example Dry Run

stack = MinStack()

stack.push(-2)   # stack = [[-2, -2]]
stack.push(0)    # stack = [[-2, -2], [0, -2]]
stack.push(-3)   # stack = [[-2, -2], [0, -2], [-3, -3]]

print(stack.getMin())  # returns -3

stack.pop()      # removes [-3, -3]
print(stack.top())     # returns 0
print(stack.getMin())  # returns -2
