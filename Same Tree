 Same Tree

ğŸ§© Problem Statement

Given the roots of two binary trees p and q, determine if they are identical or not.

Two binary trees are considered the same if:

1. They have the same structure, and


2. The nodes have the same values at corresponding positions.




---

ğŸ’¡ Example 1

Input:

p:     1          q:     1
      / \               / \
     2   3             2   3

Output:

True

âœ… Both trees are identical.


---

ğŸ’¡ Example 2

Input:

p:     1          q:     1
      /                 \
     2                   2

Output:

False

âŒ Structure differs.


---

ğŸ’¡ Example 3

Input:

p:     1          q:     1
      / \               / \
     2   1             1   2

Output:

False

âŒ Node values differ.


---

ğŸ§  Approach

We use recursion to compare both trees node by node.

Steps:

1. If both nodes are None, return True (both subtrees are empty).


2. If only one is None, return False (structure mismatch).


3. If values differ, return False.


4. Otherwise, recursively check:

Left subtrees â†’ isSameTree(p.left, q.left)

Right subtrees â†’ isSameTree(p.right, q.right)



5. Return True only if all checks pass.






ğŸ§¾ Line-by-Line Explanation

Line	Explanation

if not p or not q:	Checks if one or both nodes are None.
return p == q	Returns True if both are None, False if one is None.
p.val == q.val	Compares current node values.
self.isSameTree(p.left, q.left)	Recursively checks left subtrees.
self.isSameTree(p.right, q.right)	Recursively checks right subtrees.
and	Ensures all conditions must be True.



---

ğŸ” Dry Run

Input:

p = [1,2,3]
q = [1,2,3]

Steps:

Step	p.val	q.val	Action

1	1	1	Values same â†’ check subtrees
2	2	2	Values same â†’ check subtrees
3	None	None	True
4	3	3	Values same â†’ check subtrees
5	None	None	True
âœ… All True â†’ Final Output: True			



---

â± Complexity Analysis

Type	Complexity	Explanation

Time	O(n)	Each node is visited once
Space	O(h)	Recursion stack (h = height of the tree)
