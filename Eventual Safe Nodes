Eventual Safe Nodes

 Problem Statement
You are given a *directed graph*, where each node points to some other nodes.  
A node is called *eventually safe* if every possible path starting from it *leads to a terminal node* and *never enters a cycle*.

### âœ” Safe Node  
A node is safe if:
- It is *not* part of a cycle  
- It does *not lead* to any node that is part of a cycle  
- All outgoing edges eventually reach safe nodes  

### ğŸ¯ Goal  
Return *all safe nodes* in *increasing order*.

---

## ğŸ§  Approach

We perform a *DFS with memoization*:

- Use a dictionary safe to store each nodeâ€™s status:
  - safe[i] = True â†’ node i is safe  
  - safe[i] = False â†’ node i is unsafe or currently being explored  
- If a node revisits itself during DFS â†’ it is part of a *cycle*, so unsafe  
- If *any* neighbor is unsafe â†’ current node is unsafe  
- If *all* neighbors are safe â†’ current node is safe  

Finally, we collect all nodes marked safe.


---

ğŸ“ Explanation of Key Steps

ğŸ”¹ Step 1:

Store results of nodes in a dictionary safe to avoid repeated DFS.

ğŸ”¹ Step 2:

Mark a node as False before exploring neighbors to detect cycles.

ğŸ”¹ Step 3:

If any neighbor is unsafe â†’ current node remains False.

ğŸ”¹ Step 4:

If all neighbors are safe â†’ mark the node True.

ğŸ”¹ Step 5:

Add all safe nodes to the final list.


---

ğŸ“Š Complexity

Metric	Value

Time Complexity	O(V + E) â€” DFS on each node once
Space Complexity	O(V) â€” recursion + memo
